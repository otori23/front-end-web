
1) Quiz: Fetch And Show First Planet

1a) Instructions

- checkout the first-thumb-start branch and navigate to app/scripts/app.js
- get the planet data and add the search header
- create the first thumbnail with createPlanetThumb(data)
- handle errors!
-- pass 'unknown' to the search header
-- log the error
- checkout the first-thumb-solution branch to see my code!

1b) Anonymous vs Named Functions in Then Callbacks

- the two methods below for registering then callbacks are equivalent

Method 1
--------------------
function doSomething(arg) {
  // do something with arg
}

new Promise(function(resolve) {
  resolve("arg");
})
.then(function(arg1) {
  doSomething(arg1);
})[
--------------------

Method 2
--------------------
function doSomething(arg) {
  // do something with arg
}

new Promise(function(resolve) {
  resolve("arg");
})
.then(doSomething)
--------------------

1c) Can Add Several Catches to The Chain

getJSON('../data/earth-like-results.json')
.then(function(resp) {
  addSearchHeader(resp.query);
  return getJSON(resp.results[0]);
})
.catch(function(error) { // handle error for 1st .then
  throw Error('Search Request Error');
});
.then(createPlanetThumb)
.catch(function(error) { // handle error for every other .then that comes after 1st .catch
  addSearchHeader('unknown');
  console.log(error);
});

2) Error Handling Strategies

- so far, have use .catch to handle our errors
- but there are other ways...
- Method 1 and Method 2 below are equivalent

Method 1
---------------------
get('example.json')
.then(resloveFunc)
.catch(rejectFunc)
---------------------

Method 2
---------------------
get('example.json')
.then(resloveFunc)
.then(undefined, rejectFunc)
---------------------

2a) .then(undefined, rejectFunc) <-> .catch(rejectFunc)

- both forms are equivalent

2c) get('example.json').then(resolveFunc, rejectFunc);

- full function signature for .then
- in this form, if any previous promise is rejected, the 'rejectFunc' gets called
(so, it doesn't just have to be an error on the attached promise itself)
- if previous promise resolves, then the 'resoveFunc' is called

2d) get('example.json').then(undefined, rejectFunc).then(...);

- the 1st .then does not specify a resolve function
- so, the resolved promise will skip over the 1st .then
- it will look for a resolve function in the 2nd .then

2e) Error Logic Flow

- in all cases as soon as a promise rejects, ...
- the javascript engine skips to the next reject function in the chain
- the reject function can be in a .catch or a .then

2f) .catch Method is Recommended over 2nd Argument to .then

- more maintianable code: easier to read and write

2g) Difference In Execution Order Between .then and .catch

- can't call bothe the resolve and reject functions that are part of thesame .the
- only one or the other; or neither will get called

Method 1
---------------------
// the rejectFunc can handle errors in the promises from the get and the .then

get('example.json')
.then(resloveFunc)
.catch(rejectFunc)
---------------------


Method 2
---------------------
// the reject function handles errors only from the promise associated with the get
// an error from the promise from the .then needs to be handled by another reject
// function further down the chain

get('example.json')
.then(undefined, rejectFunc)
---------------------

2h) Resolve Does Not Necesarily Mean Success
https://jakearchibald.com/2014/resolve-not-opposite-of-reject/

- not necessarily true that passing a value to resolve means the promise succeded
- read the referenced blog post above, by jake archibald

3) Quiz: Chained Thenables

- async() and recovery() return a promise
- recovery() gets the chain back on track and continuing to resolve if something goes wrong
- what numbers will be logged if an error occurs on the lines marked below?

var urls = [];
async('example.json')		--> 13
.then(function(data) {
  urls = data.urls;		--> 13
  return async(urls[0]);
})
.then(undefined, function(e) {
  console.log(1);
  return recovery();
})
.catch(function(e) {
  console.log(2);
  return recovery();		--> if no other errors occur, this cline can't run
})
.then(function() {
  console.log(3);
  return async(urls[1]);	--> 34
})
.then(async. function(e) {
  console.log(4);
  ahhhIGiveUp();
});

4) Series vs Parallel Actions

- two main strategies for performing multiple asynchronuous actions
- synchronuous code is always in series
- asynchronuous code can be in series or in parallel

