
1) Introducing the IDB Promised Library

- when user opens Wittr, want to display latest posts recived by device before going to the network
- then make a websocket connection to start receiving new posts
- display new posts + add them to set of posts you already have stored
- finally remove entries that are to old to be worth keeping
- use a database for this

2) Advantage of a Database

- you can add and remove individual posts as needed
- iterate ofver then, and query the data
- the web platform has a database called index DB

3) Index DB (IDB)

- has a bad reputation
- IDB is similar to NoSQL systems (different from relational databases)
- supported by every major browser

3a) Shape of IDB Databases

- can have multiple databases with any given name
- generally you will only have one database per app
- that database contains multiple objects stores; one for each kind of thing you want to store

3b) Examples of object stores

- posts
- preferences
- users

3c) Object Stores (images/object_store_key.jpeg)

- contain multiple values
- e.g. JavaScript objects, strings, numbers, dataes, or arrays
- items in the object stores can have a separate primary key
- or, you can assign a property of the values to be the key
- key must be uniqe within an object store
- it becomes the way to identify a particular object

- later, get, set, add, remove, iterate over items in object stores as part of a transaction

4) Transaction

- all read/write operations in IDB must be part of a transaction
- i.e. if you create a transaction for a series of steps, and one of the actions fail, none of them are applied
- the state of the database would be as if none of the steps happened

4a) Example of Steps in a Transaction

- Add "hello:world" to "keyval" store
- Get the first value from the "people" store
- Change the persons' name to "James"
- Write it back to the "people" store

5) Indexes in Object Store (image/indexes.jpeg)

- you can also create indexes within an object store
- they provide a different view of the same data ordered by particular properites

6) Why Does IDB hava a BAD Reputation

- the API is awful
- the API forces you to create spaghetti code
- it is asynchronuous, and it pre-dates promises
- sort of has itw own event-based promise system which is confusing

6a) Note on IDB's API

- it is too clumsy, so instructore will use an abstraction library instead of IDB's API directly

7) IndexedDB Promised (https://github.com/jakearchibald/indexeddb-promised)

- an abstraction of the native IDB API
- a small library that mirrors the native IDB API
- it uses promises rather than events
- other than that, it is thesame as IDB
- so anything you learn about the library, you can apply to native IDB directly
- for the most part this also works in the reverse direction
- i.e. you can use IDB documentation to understand what the library is doing

10) Getting Started with IDB

10a) localhost:8888/idb-test/

- just a blank page with a script tag

10b) public/js/idb-test/index.js

- all it contains is an import for the idb library we will use

11) idb.open(name, version, upgradeCallback)

- create a new (or open exisiting) database

import idb from 'idb';

idb.open('test-db', 1, function(upgradeDb) {

});

11a) upgradeCallback Argument

- this function is called if the browser has not heard about this database before
- also, called if the version of the db the browser knows about is less than the version # passed in
- for database integrity this is the only place you can create and remove objectsotres and indexes

11b) upgradeDb argument to upgradCallBack

- used to define the database; i.e. the model/handle that represents the database
- api for upgradDb is in the library doc
- upgradDb really just a mirror of the native idb api; but for a few minor differences
- so can get information directly from Mozilla Developer Network (MDN)

11c) The Minor Differences

- covered in library docs
- the library docs says library db createObjectStore similat to native db's idbDatabase.createObjectStore
- so, go to MDN for full story (api) of database object 

12) Create a DataStore

import idb from 'idb';

idb.open('test-db', 1, function(upgradeDb) {
  var keyValStore = upgradeDb.createObjectStore('keyval');
});

- create the 'keyValStore' datastore
- by default datastore has keys that are separate from the data
- typically what you want
- you can inline the key and data into a single entity if you choose (see item 3c)

13) Object Store API

- the library's version of the objectstore is same as native object store
- however the library's object store returns promises
- this makes it way more usable than plain IDB

14) objectStore.put(myItem, optionalKey)

var dbPromise = idb.open('test-db', 1, function(upgradeDb) {
  var keyValStore = upgradeDb.createObjectStore('keyval');
  keyValStore.put('world', 'hello');
});

- can look up .put api on MDN
- the native IDB api returns a request object
- these request objects are what make IDB a pain to deal with
- therefore, the library version returns a promise instead
- note the input args are: (value, key) 
- NOT (key, value)

14a) dbPromise

- the library idb.open returns a promise object
- this promise resolve to the database object
- later, we can use this database object to get and set items in the database

25) Reading from DataBase - Use Transactions + dataStore.get(key)

// read "hello" in "keyval"
dbPromise.then(function(db) {
  var tx = db.transaction('keyval');
  var keyValStore = tx.objectStore('keyval');
  return keyValStore.get('hello');
}).then(function(val) {
  console.log('The value of "hello" is:', val);
});

- the code for transactions seems repetative
- however, it is possible to have a transaction that uses multiple object stores 

26) Write to Database = Use Transaction + objectStore.put

// set "foo" to be "bar" in "keyval"
dbPromise.then(function(db) {
  var tx = db.transaction('keyval', 'readwrite'); // notice 2nd parameter
  var keyValStore = tx.objectStore('keyval');
  keyValStore.put('bar', 'foo');
  return tx.complete;
}).then(function() {
  console.log('Added foo:bar to keyval');
});

- .put returns a promise
- however this promise does not necessarily signal that the put operation worked
- as we saw, if the transaction fails, all the operations that were part of the transactions are undone
- this ensures that you data is not left in some half-baked state
- either all of it happens or none of it happened

16a) Transaction.complete

- a promise that fulfills if and when the transaction completes
- and it rejects if it fails

