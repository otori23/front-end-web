
1) An Overview Of Service Worker

- all it is, is a simple javascript file that sits between you and netwok requests
- it is a type of Web Worker: run separately from your page and can't access the DOM
- but does control pages by intercepting requests as the browser makes them

1a) What Happens After a Request has Been Intercepted

- you can sent the request on to the network as ususal (i.e. through the cache)
- or you can skip the network go to some kind of cache and create a response with information from the cache

2) Register a Service Worker with the Browser

navigator.serviceWorker.register('/sw.js')

- sw.js is your service worker scripts
- this line returns a promise
- so, you get callbacks for success and failure

navigator.serviceWorker.register('/sw.js')
.then(function(reg) {
  console.log('Yay!');
})
.catch(function(err) {
  console.log('Boo!');
});

- if your register a service worker that is already registered, the browser won't register it again
- it will just return the promise associated with the already registered service worker

3) Service Worker Scope

- you can provide a scope to the sevice worker when it is registered
- the service worker will control any page whose url begins with the scope
e.g. /my-app/ | /my-app/hello/world/

- it will ignore those pages that don't begin with the scope
eg.g / | /another-app/ | /my-app (this last one does not have the trailing slash)

navigator.serviceWorker.register('/sw.js', {
  scope: '/my-app/'
});

3a) Multiple Service Workers with Different Scopes

- can have multiple service workers with different scopes
- this is handy say for github pages where multiple projects have same origin
- now you can have a different service worker for each project

https://jakearchibald.github.io/svgomg/
https://jakearchibald.github.io/trained-to-thrill/
https://jakearchibald/github.io/isserviceworkerready/

3b) Default Scope

- determined by the location of the service worker script
- basically the path that the script sits in

SW URL 			Default Scope
/foo/sw.js		/foo/
/foo/bar/sw.js		/foo/bar/
/sw.js			/

- so ususally you don't need to set the scope, you just put the sw in the right place

3c) What is Happening Within the Service Worker

- you listen for specific events
- will introudce these events as course progresses

self.addEventListener('install', function(event) {
  // ...
});

self.addEventListener('activate', function(event) {
  // ...
});

self.addEventListener('fetch', function(event) {
  // ...
});

4) Find Out About Service Worker Support

https://jakearchibald.github.io/isserviceworkerready/

- as of 2015: chrome + opera support it; firefox on its way
- can use it right away though to improve UX
- if browser does not support then users just don't get the good UX

4a) Make Sure to Wrap Code in a Simple Feature Detect

if(navigator.serviceWorker) {
  navigator.serviceWorker.register('/sw.js'); // only runs when browser supports this feature
}

5) wittr/public/js/sw/index.js

- add ServiceWorker to Wittr Project and mess around with requests
- make changes to index.js, bulid system picks it up
- navigate to localhost:8888/sw.js to see changes; extra output in file is from Babel

6) Add Listener for Service Worker "fetch" Event

self.addEventListener('fetch', function() {
  console.log(event.request);
});

- the request for the page's html, in the scope of the sw, 1st goes to the sw
- this triggers a 'fetch' event in the service worker
- there is also a 'fetch' event for every request triggered by the page (css, js, images, etc)
- event if these requests are to another origin
- you can inspect the request in the 'fetch' event listener

7) Registering a Service Worker

- the sw does nothing until you register it with the browser

7a) localhost:8888/sw.js

- see contents of file: babel output + your handler 

7b) wittr/public/js/main/IndexController.js

- this is where you register the sw
- the construction if IndexController sets up the app
- setups up views to get ready for recieving witts
- also, sets up the websocket for the live updates

7c) "Private" Methods in JS begin with Underscore

- js does not have private methods
- but by convention any method that begins with "_" is considered "private"

7d) this._registerServiceWorker

- add registration code here
- the scopte is the entire origin so the default scope is fine

7e) Test on Config Page

Test ID = registered

7f) Solution

- register sw without errors
- avoid errors in older browsers
- log message on success
- log message on failure

IndexController.prototype._registerServiceWorker = function() {
  // avoid errors in older browsers
  if(!navigator.serviceWorker) return;

  navigator.serviceWorker.register('/sw.js')
  .then(function() {
    console.log('Registration worked!');
  })
  .catch(function() {
    console.log('Registration failed');
  });
});

8) SW Event Handler - Limited to HTTPS

- HTTPS: secure form of HTTP
- has access to the request
- can modify the request here (e.g. its headers)

9) HTTP vs HTTPS

- with plain http, any node between the client and server can access and modify the request
- so, without encryption, a client can get content that is very different from what was requested
- malicious scripts can:
-- capture your input data
-- alter databases
-- read cookies
- https encrypts the request

9a) SW

- the sw has a different lifecycle than the pages
- the sw lives longer that pages, so they can be used to persist an attack like this
- BAD!!!
- so, it is not acceptable to allow a malicious middle man to get control of your sw
- so, that is why sw only operates on https requests
- but requests to localhost are exempt; i.e. can be http

10) The Service Worker Lifecycle -  is Complex

- when we create sw, it took 2 refreshes to see the console.log output from the sw event handler
- also, when you edited event handler, takes 2 refreshes again to see new console.log

10a) SW LifeCycle Process

- start with window client for page that does not have sw defined
- make code changes to add sw and do a refresh
- new window client is created for page that has sw registered; old window client goes away
- the new page makes request for all of its resources then registers the sw
- sw only takes control of page when the page is loaded
- so, the sw has no control over the currently loaded page (i.e. the page that requested for it)
- then now when you do a refresh, the sw already exists and will take control of the new page loaded

10b) Making a New Version of SW

- if a page loads via a sw, it will check for a change to the sw in the background
- when a new sw is loaded; it waits until all pages using the old service work are gone
- then the new sw takes control of loaded pages

10c) Forcing Using a New Version of the SW

- will need to naviagate to another domain
- then navigate back to the domain with SW
- this forces the old SW to be removed, then the new SW that was waiting can now take control

10d) Similar to Update Process for Browsers (e.g. Chrome)

- chrome will download its update in the background
- but these updates don't take effect until the browser is closed and then opened again
- hamburger icon on top right is colored 'green' to notify user that there is a pending update available

10e) HTTP Cache Time

- when browser refetches a sw looking for updates, it goes through the browsers HTTP cache
- so, it is strongly recommended to keep the cache time on your service worker short
- instructor uses a cache time of 0, on all of his sw projects
- if you set your sw script to cache for more than a day, the browsers will ignore limit time to 24 hrs

11) Enabling Service Worker Dev Tools (in Chrome Canaray)

- dev tools that show you what state the service work is in

11a) Chrome Canary

- nightly build of chrome that has all the latest stuff

12) Service Worker Dev Tools

- demonstrate servic worker lifecycle and developer tools to observe it

12a) The Console Tab - Default Context

- any code you run in the console, will run against the window object by default
- i.e. the code runs in the context of the window (golbal object); so, self = the window object
- so, at this point, self.registration, which only exists in service worker, is undefined

12b) The Console Tab - Switch Context

- can use tool bar item to switch context to that of sw
- so, now self = the sw object; self.registration does have meaning

12c) The Debugger (Sources Tab) - Works With ServiceWorker

- go to the sources panel, find the code for service worker and debug it like any other js code in project
- can set a break-point in the fetch event
- when the bugger pauses your code, you can inspect variable values, stack trace, etc in debugger

12d) The Resources Tab

- sw has its own panel in the resources tab
- on the sw panel, can use 'bin' icon to unregister the sw
- this is useful if you want to refetch the sw from scratch
- the tabs within the sw panel, give you insight into the sw lifecycle
- i.e. can select appropriate tab to see which sw is installing, waiting, active, or redundant
- if a tab is greyed out, this means there are no sw's in that state

12e) Quiz: Service Worker Dev Tools - SW 

- to get the project into the sample state use the commands
git reset --hard
git checkout log-requests

- then make a change to sw and get it into a waiting state

- once the task is completed: enter the Test ID = sw-waiting into config server

12f) Quiz: Service Worker Dev Tools - SW Active

- make the waiting sw active
- do this by either closing all windows that are using the current sw
- or, navigate to a page that isn't in the sw's scope
- once completed, enter the Test ID sw-active

13) Service Worker Dev Tools Continued

- closing tab or navigating to another domain is a bit of a pain during development
- there are other ways to get your sw on client to update when changes are made on the server

13a) Reload Page + Shift

- loads the page but bypasses the service worker
- this behaviour is part of teh service worker spec
- causes an already "waiting" service worker to become active
- need to do another page reload to start using the newly active service worker
- i.e. get the console output of the newly activated sw
- quick way to test minor chages unrealated to the service worker (i.e. minor css changes)

13b) GET http://localhost:8888/sw.js net::ERR_FILE_EXISTS

- an output line in console
- chorme is saying th has checked the service worker and there were no changes
- this is a bug in chromes behaviour, but, it does not break anything

13c) Source Tab -> Service Workers Tab -> "Force update on page load" checkbox

- change sw life cycle to be developer friendly
- in this mode when you reload a page, the sw is always fetched and immediately made active, ...
- then the page refreshes, so you see the console logs immediately
- no need for an additional refresh
- this change in behaviour only happens when dev tools is open; makes view quick changes really easy

13d) Caveat with "Force update on page load" method

- this is note thesame lifecycle users will be getting
- only happening in developer environment while the tab is openned

13e) Resources Tab -> SW Panel -> State Colors

- active service worker has red icon
- waiting service worker has green icon

14) Hijacking Requests

- currently server is having all the fun when it comes to sending content back to the browser 
- now it's our turn to have fun

so far:

browser <-> service worker <-> HTTP cache <-> Internet (i.e. the server)

by now:

browser <-> service worker

- nothing will go to the network
- this is an important step in going offline first

14a) event.respondWith()

- this tells the browser that the sw will handle the response
- no need to get response from the network
- this method takes a response object or a promise that resolves with a response

14b) new Response()

- one way to create a response object
- 1st parameter is the body of the response (blob, buffer, string, etc.)

self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('Hello World')
  );
});

14c) Respond With HTML

self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('Hello <b>World</b>')
  );
});

- the browser will just print out the response string as plain text
- i.e. the browser will not interprete the string as markup

14d) Network Tab -> Response Headers

content-type: text/plain;charset=UTF-8

- this means the browser will not parse the response as html
- need to change this to allow browser to interprete response as markup
- use the second parameter in Response object constructor to specify response headers

14e) Second Argument of Response Constructor

- an object; the 'headers' property is an object of headers and values

self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('Hello <b>World</b>', {
     headers: {'foo': 'bar'})
  );
});

- the code above will show the response header to be:

content-type: text/plain;charset=UTF-8
foo: bar

15) Quiz: Hijacking Requests 1 Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout task-custom-response

- return html repsonse (header contains: content-type: text/html)
- have an element with class "a-winner-is-me"
- once completing the task enter the Test ID html-response

self.addEventListener('fetch', function(event) {
	// TODO: respond to all requests with an html response
	// containing an element with class="a-winner-is-me".
	// Ensure the Content-Type of the response is "text/html"
  event.respondWith(
    new Response('Hello <b class="a-winner-is-me">World</b>', {
      headers: {'Content-Type': 'text/html'}
    })
  );
});

15a) Goal With Hijacking Requests

- hijack particular requests in particular ways
- depending on the information in the request and the response

16) Hijacking Requests 2 - Goto Network for Response but not for what was Originally Requested

- will use the fetch api for this

16a) fetch(url)

- lets you make network requests and lets you read the response
- an improvement on the XHR api which is 15 years old at this point
- XHR was not particularly well thought out to begin with

16b) Problem with XHR

- deals with many different response types; not just XML (think json)
- deals with other protocols; not just HTTP (think file system)
- the returned object is like a strange mixture of request and response
- which is XML all caps but only the H in http is in caps
- the code is cumbersome to use; the flow just feels like it is in the wrong order
- does not support promises, so you end up with deeply nested callback code (tower of doom)
- does not support lower level things like streams
- have to declare response type before you even make the request
- compare XHR api and fetch api

16c) XHR Code

var client = new XMLHttpRequest();

client.addEventListener('load', function() {
  console.log(client.response);
});

client.addEventListener('error', function() {
  console.log("It failed");
});

client.responseType = 'json';
client.open('GET', '/foo');
client.send();

16d) Fetch Code

fetch('/foo')
.then(function(response) {
  return response.json();
})
.then(function(data) {
  console.log(data);
})
.catch(function() {
  console.log('It failed');
});

- cleaner
- supports promises
- elegant error handling

16e) Back to Crafting a Response

- remember, event.respondWith takes a response, or a promise that resolves to a response
- the 'fetch' api returns a promise that resolves to a response
- so, it composes well with event.respondWith

self.addEventListener('fetch', function(event) {
  event.respondWith(
    fetch('/imgs/dr-evil.gif')
  );
});

- fetch does a normal browser fetch, so results may come from the browser HTTP cache
- this is a benefit in this case

16f) Quiz: Hijacking Requests 2 Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout gif-response

- want to hijack only particular requests
- take a look at code in: public/js/sw/index.js
- only respond to requests with a url ending in ".jpeg"
- event.request gives you information about the request
- once completing the task enter the Test ID gif-response


self.addEventListener('fetch', function(event) {
  // TODO: only respond to requests with a
  // url ending in ".jpg"
  if(event.request.url.endsWith('.jpg')) {
  	event.respondWith(fetch('/imgs/dr-evil.gif'));
  }
});

17) Hijacking Requests 3

- explore some request hijacking patterns