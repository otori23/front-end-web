
1) An Overview Of Service Worker

- all it is, is a simple javascript file that sits between you and netwok requests
- it is a type of Web Worker: run separately from your page and can't access the DOM
- but does control pages by intercepting requests as the browser makes them

1a) What Happens After a Request has Been Intercepted

- you can sent the request on to the network as ususal (i.e. through the cache)
- or you can skip the network go to some kind of cache and create a response with information from the cache

2) Register a Service Worker with the Browser

navigator.serviceWorker.register('/sw.js')

- sw.js is your service worker scripts
- this line returns a promise
- so, you get callbacks for success and failure

navigator.serviceWorker.register('/sw.js')
.then(function(reg) {
  console.log('Yay!');
})
.catch(function(err) {
  console.log('Boo!');
});

- if your register a service worker that is already registered, the browser won't register it again
- it will just return the promise associated with the already registered service worker

3) Service Worker Scope

- you can provide a scope to the sevice worker when it is registered
- the service worker will control any page whose url begins with the scope
e.g. /my-app/ | /my-app/hello/world/

- it will ignore those pages that don't begin with the scope
eg.g / | /another-app/ | /my-app (this last one does not have the trailing slash)

navigator.serviceWorker.register('/sw.js', {
  scope: '/my-app/'
});

3a) Multiple Service Workers with Different Scopes

- can have multiple service workers with different scopes
- this is handy say for github pages where multiple projects have same origin
- now you can have a different service worker for each project

https://jakearchibald.github.io/svgomg/
https://jakearchibald.github.io/trained-to-thrill/
https://jakearchibald/github.io/isserviceworkerready/

3b) Default Scope

- determined by the location of the service worker script
- basically the path that the script sits in

SW URL 			Default Scope
/foo/sw.js		/foo/
/foo/bar/sw.js		/foo/bar/
/sw.js			/

- so ususally you don't need to set the scope, you just put the sw in the right place

3c) What is Happening Within the Service Worker

- you listen for specific events
- will introudce these events as course progresses

self.addEventListener('install', function(event) {
  // ...
});

self.addEventListener('activate', function(event) {
  // ...
});

self.addEventListener('fetch', function(event) {
  // ...
});

4) Find Out About Service Worker Support

https://jakearchibald.github.io/isserviceworkerready/

- as of 2015: chrome + opera support it; firefox on its way
- can use it right away though to improve UX
- if browser does not support then users just don't get the good UX

4a) Make Sure to Wrap Code in a Simple Feature Detect

if(navigator.serviceWorker) {
  navigator.serviceWorker.register('/sw.js'); // only runs when browser supports this feature
}

5) wittr/public/js/sw/index.js

- add ServiceWorker to Wittr Project and mess around with requests
- make changes to index.js, bulid system picks it up
- navigate to localhost:8888/sw.js to see changes; extra output in file is from Babel

6) Add Listener for Service Worker "fetch" Event

self.addEventListener('fetch', function() {
  console.log(event.request);
});

- the request for the page's html, in the scope of the sw, 1st goes to the sw
- this triggers a 'fetch' event in the service worker
- there is also a 'fetch' event for every request triggered by the page (css, js, images, etc)
- event if these requests are to another origin
- you can inspect the request in the 'fetch' event listener

7) Registering a Service Worker

- the sw does nothing until you register it with the browser

7a) localhost:8888/sw.js

- see contents of file: babel output + your handler 

7b) wittr/public/js/main/IndexController.js

- this is where you register the sw
- the construction if IndexController sets up the app
- setups up views to get ready for recieving witts
- also, sets up the websocket for the live updates

7c) "Private" Methods in JS begin with Underscore

- js does not have private methods
- but by convention any method that begins with "_" is considered "private"

7d) this._registerServiceWorker

- add registration code here
- the scopte is the entire origin so the default scope is fine

7e) Test on Config Page

Test ID = registered

7f) Solution

- register sw without errors
- avoid errors in older browsers
- log message on success
- log message on failure

IndexController.prototype._registerServiceWorker = function() {
  // avoid errors in older browsers
  if(!navigator.serviceWorker) return;

  navigator.serviceWorker.register('/sw.js')
  .then(function() {
    console.log('Registration worked!');
  })
  .catch(function() {
    console.log('Registration failed');
  });
});

8) SW Event Handler - Limited to HTTPS

- HTTPS: secure form of HTTP
- has access to the request
- can modify the request here (e.g. its headers)

9) HTTP vs HTTPS

- with plain http, any node between the client and server can access and modify the request
- so, without encryption, a client can get content that is very different from what was requested
- malicious scripts can:
-- capture your input data
-- alter databases
-- read cookies
- https encrypts the request

9a) SW

- the sw has a different lifecycle than the pages
- the sw lives longer that pages, so they can be used to persist an attack like this
- BAD!!!
- so, it is not acceptable to allow a malicious middle man to get control of your sw
- so, that is why sw only operates on https requests
- but requests to localhost are exempt; i.e. can be http

10) The Service Worker Lifecycle -  is Complex

- when we create sw, it took 2 refreshes to see the console.log output from the sw event handler
- also, when you edited event handler, takes 2 refreshes again to see new console.log

10a) SW LifeCycle Process

- start with window client for page that does not have sw defined
- make code changes to add sw and do a refresh
- new window client is created for page that has sw registered; old window client goes away
- the new page makes request for all of its resources then registers the sw
- sw only takes control of page when the page is loaded
- so, the sw has no control over the currently loaded page (i.e. the page that requested for it)
- then now when you do a refresh, the sw already exists and will take control of the new page loaded

10b) Making a New Version of SW

- if a page loads via a sw, it will check for a change to the sw in the background
- when a new sw is loaded; it waits until all pages using the old service work are gone
- then the new sw takes control of loaded pages

10c) Forcing Using a New Version of the SW

- will need to naviagate to another domain
- then navigate back to the domain with SW
- this forces the old SW to be removed, then the new SW that was waiting can now take control

10d) Similar to Update Process for Browsers (e.g. Chrome)

- chrome will download its update in the background
- but these updates don't take effect until the browser is closed and then opened again
- hamburger icon on top right is colored 'green' to notify user that there is a pending update available

10e) HTTP Cache Time

- when browser refetches a sw looking for updates, it goes through the browsers HTTP cache
- so, it is strongly recommended to keep the cache time on your service worker short
- instructor uses a cache time of 0, on all of his sw projects
- if you set your sw script to cache for more than a day, the browsers will ignore limit time to 24 hrs

11) Enabling Service Worker Dev Tools (in Chrome Canaray)

- dev tools that show you what state the service work is in

11a) Chrome Canary

- nightly build of chrome that has all the latest stuff

12) Service Worker Dev Tools

- demonstrate servic worker lifecycle and developer tools to observe it

12a) The Console Tab - Default Context

- any code you run in the console, will run against the window object by default
- i.e. the code runs in the context of the window (golbal object); so, self = the window object
- so, at this point, self.registration, which only exists in service worker, is undefined

12b) The Console Tab - Switch Context

- can use tool bar item to switch context to that of sw
- so, now self = the sw object; self.registration does have meaning

12c) The Debugger (Sources Tab) - Works With ServiceWorker

- go to the sources panel, find the code for service worker and debug it like any other js code in project
- can set a break-point in the fetch event
- when the bugger pauses your code, you can inspect variable values, stack trace, etc in debugger

12d) The Resources Tab

- sw has its own panel in the resources tab
- on the sw panel, can use 'bin' icon to unregister the sw
- this is useful if you want to refetch the sw from scratch
- the tabs within the sw panel, give you insight into the sw lifecycle
- i.e. can select appropriate tab to see which sw is installing, waiting, active, or redundant
- if a tab is greyed out, this means there are no sw's in that state

12e) Quiz: Service Worker Dev Tools - SW 

- to get the project into the sample state use the commands
git reset --hard
git checkout log-requests

- then make a change to sw and get it into a waiting state

- once the task is completed: enter the Test ID = sw-waiting into config server

12f) Quiz: Service Worker Dev Tools - SW Active

- make the waiting sw active
- do this by either closing all windows that are using the current sw
- or, navigate to a page that isn't in the sw's scope
- once completed, enter the Test ID sw-active

13) Service Worker Dev Tools Continued

- closing tab or navigating to another domain is a bit of a pain during development
- there are other ways to get your sw on client to update when changes are made on the server

13a) Reload Page + Shift

- loads the page but bypasses the service worker
- this behaviour is part of the service worker spec
- causes an already "waiting" service worker to become active
- need to do another page reload to start using the newly active service worker
- i.e. get the console output of the newly activated sw
- quick way to test minor chages unrealated to the service worker (i.e. minor css changes)

13b) GET http://localhost:8888/sw.js net::ERR_FILE_EXISTS

- an output line in console
- chorme is saying th has checked the service worker and there were no changes
- this is a bug in chromes behaviour, but, it does not break anything

13c) Source Tab -> Service Workers Tab -> "Force update on page load" checkbox

- change sw life cycle to be developer friendly
- in this mode when you reload a page, the sw is always fetched and immediately made active, ...
- then the page refreshes, so you see the console logs immediately
- no need for an additional refresh
- this change in behaviour only happens when dev tools is open; makes view quick changes really easy

13d) Caveat with "Force update on page load" method

- this is note thesame lifecycle users will be getting
- only happening in developer environment while the tab is openned

13e) Resources Tab -> SW Panel -> State Colors

- active service worker has red icon
- waiting service worker has green icon

14) Hijacking Requests

- currently server is having all the fun when it comes to sending content back to the browser 
- now it's our turn to have fun

so far:

browser <-> service worker <-> HTTP cache <-> Internet (i.e. the server)

by now:

browser <-> service worker

- nothing will go to the network
- this is an important step in going offline first

14a) event.respondWith()

- this tells the browser that the sw will handle the response
- no need to get response from the network
- this method takes a response object or a promise that resolves with a response

14b) new Response()

- one way to create a response object
- 1st parameter is the body of the response (blob, buffer, string, etc.)

self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('Hello World')
  );
});

14c) Respond With HTML

self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('Hello <b>World</b>')
  );
});

- the browser will just print out the response string as plain text
- i.e. the browser will not interprete the string as markup

14d) Network Tab -> Response Headers

content-type: text/plain;charset=UTF-8

- this means the browser will not parse the response as html
- need to change this to allow browser to interprete response as markup
- use the second parameter in Response object constructor to specify response headers

14e) Second Argument of Response Constructor

- an object; the 'headers' property is an object of headers and values

self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('Hello <b>World</b>', {
     headers: {'foo': 'bar'})
  );
});

- the code above will show the response header to be:

content-type: text/plain;charset=UTF-8
foo: bar

15) Quiz: Hijacking Requests 1 Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout task-custom-response

- return html repsonse (header contains: content-type: text/html)
- have an element with class "a-winner-is-me"
- once completing the task enter the Test ID html-response

self.addEventListener('fetch', function(event) {
	// TODO: respond to all requests with an html response
	// containing an element with class="a-winner-is-me".
	// Ensure the Content-Type of the response is "text/html"
  event.respondWith(
    new Response('Hello <b class="a-winner-is-me">World</b>', {
      headers: {'Content-Type': 'text/html'}
    })
  );
});

15a) Goal With Hijacking Requests

- hijack particular requests in particular ways
- depending on the information in the request and the response

16) Hijacking Requests 2 - Goto Network for Response but not for what was Originally Requested

- will use the fetch api for this

16a) fetch(url)

- lets you make network requests and lets you read the response
- an improvement on the XHR api which is 15 years old at this point
- XHR was not particularly well thought out to begin with

16b) Problem with XHR

- deals with many different response types; not just XML (think json)
- deals with other protocols; not just HTTP (think file system)
- the returned object is like a strange mixture of request and response
- which is XML all caps but only the H in http is in caps
- the code is cumbersome to use; the flow just feels like it is in the wrong order
- does not support promises, so you end up with deeply nested callback code (tower of doom)
- does not support lower level things like streams
- have to declare response type before you even make the request
- compare XHR api and fetch api

16c) XHR Code

var client = new XMLHttpRequest();

client.addEventListener('load', function() {
  console.log(client.response);
});

client.addEventListener('error', function() {
  console.log("It failed");
});

client.responseType = 'json';
client.open('GET', '/foo');
client.send();

16d) Fetch Code

fetch('/foo')
.then(function(response) {
  return response.json();
})
.then(function(data) {
  console.log(data);
})
.catch(function() {
  console.log('It failed');
});

- cleaner
- supports promises
- elegant error handling

16e) Back to Crafting a Response

- remember, event.respondWith takes a response, or a promise that resolves to a response
- the 'fetch' api returns a promise that resolves to a response
- so, it composes well with event.respondWith

self.addEventListener('fetch', function(event) {
  event.respondWith(
    fetch('/imgs/dr-evil.gif')
  );
});

- fetch does a normal browser fetch, so results may come from the browser HTTP cache
- this is a benefit in this case

16f) Quiz: Hijacking Requests 2 Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout gif-response

- want to hijack only particular requests
- take a look at code in: public/js/sw/index.js
- only respond to requests with a url ending in ".jpeg"
- event.request gives you information about the request
- once completing the task enter the Test ID gif-response


self.addEventListener('fetch', function(event) {
  // TODO: only respond to requests with a
  // url ending in ".jpg"
  if(event.request.url.endsWith('.jpg')) {
  	event.respondWith(fetch('/imgs/dr-evil.gif'));
  }
});

17) Hijacking Requests 3

- explore some request hijacking patterns
- another thing we can do, in the sw 'fetch' handler, is send the request to the network...
- analyze the response and send some other information to the browser

17a) Example Custom Failure Message

self.addEventListener('fetch', function(evetn) {
  event.respondWith(
    fetch(event.request).then(function(response) {
      if(response.status == 404) { // was able to reach the server
        return new Response("Whoops, not found"); // resource does not exist on server; network is active
      }
      return response;
    }).catch(function() { // was not able to reach the server
      return new Response("Uh oh, that totally failed"); // for cases where network not active 
    })
  );
});

17b) Can Create Complex Rules for Requests

- so can get response from multiple sources, and use these results to craft one response to page
- can go to network, if that fails, go somewhere else on network, or go somewhere locally
- i.e. chain two fetch request together

18) Quiz: Hijacking Requests 3 Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout error-handling

- so we have seen a custom 404 message served by sw
- but what if we want to serve an image instead
- take a look at code in public/js/sw/index.js
- so, instead of text resonpse, fetch git from network an show gif instead

- once completing the task enter the Test ID gif-404

18b) Solution

- if you return a promise within a promise, it passes the eventual value to the outer promise

self.addEventListener('fetch', function(event) {
  event.respondWith(
    fetch(event.request).then(function(response) {
      if (response.status === 404) {
        // TODO: instead, respond with the gif at
        // /imgs/dr-evil.gif
        // using a network request
        //return new Response("Whoops, not found");
        return fetch('/imgs/dr-evil.gif');
      }
      return response;
    }).catch(function() {
      return new Response("Uh oh, that totally failed!");
    })
  );
});

19) Caching and Serving Assets

- to make wittr truly offline first, we need somewhere to store the app's assests
- i.e. the HTML, CSS, JS, images, fonts, etc
- this is where the cache API comes in

20) The Cache API

- gives use the caches object on the global object 

20a) Windows.caches (https://developer.mozilla.org/en-US/docs/Web/API/Window/caches) 

-  read-only property 
- returns the CacheStorage object associated with the current origin
- enables service worker functionality 
- such as storing assets for offline use, and generating custom responses to requests

20b) Open Cache with Name = "my-stuff"

caches.open('my-stuff').then(function(cache) {
  //...
});

20c) The Cache - What Does 'my-stuff' Contain; How is it Structured?

- a cache box contains request and response pairs from any secure origin
- we can use it to store fonts, scripts, images, anything...
- assest could be from our own origin as wll as elsewhere on the web

20d) Add Cache Items - cache.put, cache.addAll

cache.put(request, response);

- can pass in a request or a URL and a response

cache.addAll(['/foo', '/bar']); 

- takes an array or requests or URLs
- fetches them, and puts the request-response pairs into the cache
- the operation is atomic, if any fail to cache none of them are added
- uses fetch under the hood, so requests go via the browser cache

20e) Get Stuff Out of The Cache - cache.match

cache.match(request);

- returns a promise for a matching response if one is found
- or null otherwise

caches.match(request);

- same as cache.match, but it tries to find a response in all available caches starting with the oldest

21) The Service Worker 'install' Event

- when a browser runs a sw for the 1st time, the install event is fired for the sw
- the browser will no let the sw take control of the page until the install phase is completed
- the app programmer is in control of what is involved in the install phase of the sw

21a) The Install Phase

- use it as an opportunity to get everything we need from the network
- and create a cache for them (i.e. build the resources in the cache)

21b) Adding the 'install' Event

self.addEventListener('install', function() {
  event.waitUntil(
    <<a Promise>>
  );  
});
  
21c) event.waitUntil

- let's us signal the progress of the install
- pass it a promise
- if/when the promise resolves the browser knows that the install is complete
- if the promise rejects, the browser knows that the install failed; and the sw is discarded

22) Quiz: Install And Cache Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout task-install

- take a look at public/js/sw/index.js
- there is an array of urls defined; add these resources to a cache named 'wittr-static-v1' 

- once completing the task enter the Test ID install-cached

22a) Verify State of Cache

- go to "Resoruces" tab in Dev Tools
- select "Cache Storage" panel
- look for your cahce in there

22b) Solution

self.addEventListener('install', function(event) {
  var urlsToCache = [
    '/',
    'js/main.js',
    'css/main.css',
    'imgs/icon.png',
    'https://fonts.gstatic.com/s/roboto/v15/2UX7WLTfW3W8TclTUvlFyQ.woff',
    'https://fonts.gstatic.com/s/roboto/v15/d-6IYplOFocCacKzxwXSOD8E0i7KZn-EPnyo3HZu7kw.woff'
  ];

  event.waitUntil(
    // TODO: open a cache named 'wittr-static-v1'
    // Add cache the urls from urlsToCache
    caches.open('wittr-static-v1').then(function(cache) {
  	  return cache.addAll(urlsToCache);
    })
  );
});

self.addEventListener('fetch', function(event) {
  // Leave this blank for now.
  // We'll get to this in the next task.
});

23) Quiz: Cache Response Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout task-cache-response

- we assume you have already created the cache (as in the last step)
- your code goes in the 'fetch' handler
- the goal is to respond to the request with an entry from the cache if there is one
- or else get response from the network
- hint: you need to call event.respondWith synchronously
- hint: you can't call it within a promise handler, that's too late

- once completing the task enter the Test ID cache-served

- you can put the server in offline mode and you will still get a response

23a) Solution

self.addEventListener('install', function(event) {
  var urlsToCache = [
    '/',
    'js/main.js',
    'css/main.css',
    'imgs/icon.png',
    'https://fonts.gstatic.com/s/roboto/v15/2UX7WLTfW3W8TclTUvlFyQ.woff',
    'https://fonts.gstatic.com/s/roboto/v15/d-6IYplOFocCacKzxwXSOD8E0i7KZn-EPnyo3HZu7kw.woff'
  ];

  event.waitUntil(
    // TODO: open a cache named 'wittr-static-v1'
    // Add cache the urls from urlsToCache
    caches.open('wittr-static-v1').then(function(cache) {
  	  return cache.addAll(urlsToCache);
    })
  );
});

self.addEventListener('fetch', function(event) {
  // Leave this blank for now.
  // We'll get to this in the next task.
  event.respondWith(
    caches.match(event.request).then(function(response) {
      if(response) return response;
      return fetch(event.request);
    })
  );
});

23b) Solution Short Comings

- we don't update the posts in the cache
- this is because we cache the HTML once at install time
- so, at this point, we are always stuck with the same set of messages in the cache

23c) To do List to Get to Full Offline 1st Success

- Unobstrusive app updates
- Get the user onto the latest version of app
- Continually update cache of posts
- Cache photos
- Cache avatars

24) Updating the Static Cache

- time to disable the "Force update on page load"
- this lets you the developer experience the sw lifecycle as the user does

24a) Service Worker Forced Updates

- i.e. select this option in dev tools "Sources" tab
- great during development
- public/scss/_theme.scss - contains sass vars referenced throught the rest of the style sheets
- can change the app's theme color here
- can make a change here and have it immediately refelcted in page on page refresh

24b) Remember What Forced Update Option Does

- reloads the service worker from the network on every refresh
- the fetched service worker installs even if the service worker did not change

24c) The Service Worker Normal Life Cycle

- just a normal refresh will still give you the old css in the sw cache
- will need to to do a Shift+Refresh to bypass current service worker
- so you will get all the app assests from the server
- this means you will get the new version of the css
- there was no change to the sw code, so the install event for the service work is not invoked
- this means that the new css was never cached
- so, when you refresh page normally you get the old stale css from the sw cache

- we need to get the service worker to pick up the changes in the css

24d) Steps to Get Service Worker to Cache Changes in CSS

- to get css to update, we need to make a change in the service worker
- the browser will then treat this updated worker as a new version
- the new sw gets its own install event where it will fetch the apps resources and place in its own cahce
- we will explicitly use a brand new cache that is different the cache used by the old version of the sw
- this does not happen automatically, we actually have to specifiy a new name for a cache to create
- e.g. gchange cache name like 'wittr-static-v1' -> 'wittr-static-v2'
- the once the old service worker (& cahce) is realeased (navigate to different domain, or close window), ...
- the new sw (and its cache) will take control for the page

25) How To Get Rid of the Old Cache

25a) The Service Worker 'activate' Event

- fires when a sw becomes active
- i.e. when the sw is ready to control pages and teh previous sw is gone
- this is the perfect time to get rid of old caches

25b) event.waitUntil

- use to signal the length of the process
- while you are activating the browser will queue other service worker events such as fetch
- so, by the time the sw recieves its first fetch, youknow you have the caches created

25c) caches.delete(cacheName);

- deletes the specified cache
- returns a promise

25d) caches.keys();

- get the name of all your cahces
- returns a promise

26) Update Your CSS Quiz

- to get the project into the sample state use the commands
git reset --hard
git checkout task-handling-updates

- once completing the task enter the Test ID new-cache-ready

26a) Steps

- update the css in a way that does not disrupt the currently running version of the site
- make sure to disable "Force update on page reload" on SW tab in source tab of dev tools
- take a look at file: public/js/sw/index.js
- the task is to change the theme of the site
- all the colors are stored as sass variables
- check out the colors in file: public/cscc/_theme.scss
- just uncomment the pink/green theme at the bottom of the file
- in the sw update the cahce name
- then use the activate event to remove the old cahce
- once change are made reload page
- you should see we in the 'waiting' state
- before it activates, go to config server and enter 'new-cache-ready'

26b) Solution

i) The Easy Way

self.addEventListener('install', function(event) {
  event.waitUntil(
    // TODO: change the site's theme, eg swap the vars in public/scss/_theme.scss
    // Ensure at least $primary-color changes
    // TODO: change cache name to 'wittr-static-v2'
    caches.open('wittr-static-v2').then(function(cache) {
      return cache.addAll([
        '/',
        'js/main.js',
        'css/main.css',
        'imgs/icon.png',
        'https://fonts.gstatic.com/s/roboto/v15/2UX7WLTfW3W8TclTUvlFyQ.woff',
        'https://fonts.gstatic.com/s/roboto/v15/d-6IYplOFocCacKzxwXSOD8E0i7KZn-EPnyo3HZu7kw.woff'
      ]);
    })
  );
});

self.addEventListener('activate', function(event) {
  event.waitUntil(
    // TODO: remove the old cache
    caches.delete('wittr-static-v1')
  );
});

self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      return response || fetch(event.request);
    })
  );
});


ii) The Scalable Way

var staticCacheName = 'wittr-static-v2'; // the cahce I want to keep

self.addEventListener('install', function(event) {
  event.waitUntil(
    // TODO: change the site's theme, eg swap the vars in public/scss/_theme.scss
    // Ensure at least $primary-color changes
    // TODO: change cache name to 'wittr-static-v2'
    caches.open('wittr-static-v2').then(function(cache) {
      return cache.addAll([
        '/',
        'js/main.js',
        'css/main.css',
        'imgs/icon.png',
        'https://fonts.gstatic.com/s/roboto/v15/2UX7WLTfW3W8TclTUvlFyQ.woff',
        'https://fonts.gstatic.com/s/roboto/v15/d-6IYplOFocCacKzxwXSOD8E0i7KZn-EPnyo3HZu7kw.woff'
      ]);
    })
  );
});

self.addEventListener('activate', function(event) {
  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cachesNames.filter(function(cacheName) {
          return cacheName.startsWith('wittr-') && // basically only consider caches for witter app
                 cacheName != staticCacheName;
        }).map(function(cacheName) {
          return cahce.delete(cacheName);
        })
    );
  })
});

self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      return response || fetch(event.request);
    })
  );
});

- maintain a save list of cache names you want to keep
- remove anything that is not on the list

26c) The Browser Cache

- remember that requests go through the standard browser cache
- so if you have a resource that has a cache time of a year, any updates would just come from HTTP cache
- so you would not get any changes you made
- on the development end, can get around this you can set all resources to have a cache age of 0
- but on client, you are not in control, so you need some cahce busting strategy

26d) HTTP Cache Busting on Client

- add version numbers to your resource file names
- this can be done automatically with a build system where the version # is generate from the file contents
- this way the client browser will always have to go to the server to fecth the new version
- you could also use the build script to generate the name of the cache that you want to keep
- or any other resource for that matter

26c) Activate SW

- need to close window for all pages using sw
- or navigate all pages using sw to a different domain
- or shift+refresh
- after it activates, go to config server and enter 'new-cache-used'

27) Adding UX to the Update Process

- the goal is to tell the user once a new update has been found

- when a new worker is dicovered, ...
- it waits until all pages using the current version go away before it can take over
- this could be a while

27a) How to Alert User That a New Service Worker is Available

- present user with form which has option to 'update' or 'dismiss' 
- use the sw registration object to accomplish this

28) The ServiceWorker Registration Object

navigator.serviceWorker.register('/sw.js').then(function(reg) {
  //  methods
  reg.unregister();
  reg.update();

  // properties: will point to a service worker object or be null
  reg.installing;
  reg.waiting;
  reg.active;

  // events
  reg.addEventListener('updatefound', function() {
    // reg.installing has changed
    var sw = reg.installing;
    console.log(sw.state);
  });
});

- registering a service worker returns a promise
- this promise fulfils with a service worker registration object
- this object has properties and methods related to the service worker registration

28a) reg.unregister() and reg.update()

- can use object to unregister a service worker or programatically trigger an update

28b) reg.installing, reg.waiting, and reg.active

- also get three properties: installing, waiting, and active
- they give you insight into sw lifecycle
- they also map directly to dev tools view we've been working with so far

28c) reg.updatefound Event

- the object has an event 'updatefound' which is called when an update is found
- when this event fires, reg.installing will be the new service worker

28d) Can Inspect State in Service Worker Objects Themselves

var sw = reg.installing;
console.log(sw.state);

28e) Service Worker States [installing | installed | activating | activated | redundant]

- installing: the installer has fired, but not yet completed
- installed: the installation has successfully completed by has not yer activated
- activating: the activate event has fired but not yet complete
- activated: the serviceWorker is ready to receive fetch events
- redundant: the serviceWorker has been thrown away

28f) The 'redundant' State

- happens when the sw has been superseded by a newer worker
- or if the sw failed to install

28g) The Service Worker State Change Event

- fired whenever the value of the state property changes

sw.addEventListener('statechange', function() {
  // sw.state has changed
});

29) navigator.serviceWorker.controller

- refers to the sw that controls this page
- you want to tell the user there's and update ready
- however update happens in background
- so, the update could be: ready & waiting, it could be in progress, or it might not have started yet
- this means we need to look at the state of things when the page loads
- we also need to listen for future changes

29a) If There is no controller - navigator.serviceWorker.controller = null 

- means the page did not load using the service worker
- it loaded directly from the network instead

if(!navigator.serviceWorker.controller) {
  // page didn't load using a service worker
}

29b) Otherwise Look At the Registration

if (reg.waiting) { // alread there
  // there's ana update ready!
  // so, tell user about it
}

if (reg.installing) { // in progress
  // there's an update in progress

  // this update may fail
  // so, we listen to the state changes and track it, and...
  // if it reareahes the installed state, alert user
  
  reg.installing.addEventListener('statechange', function() {
    if (this.state == 'installed') {
      // there's an update ready!
      // so, tell the user about it
    }
  });
}

29c) Otherwise, Listen for the 'updateFound' Event

reg.addEventListener('updatefound', function () { // start sometime later

  // track the state of the installing worker
  // if it reaches the install state, we tell the user 
  reg.installing.addEventListener('statechange', function () {
    if (this.state == 'installed') {
      // there's and update ready!
      // so, tell the user about it
    }
  });
});

30) Summary of Last Item

- last item was about how to tell user about updates
- the updates may be already there, in progress, or start some time later    

31) Quiz: Adding UX Quiz

- goal is to tell the user when there is an update available

31a) public/js/main/IndexController.js

- this is where the service worker is registered
- look at the _updateReady method
- calling this method will show a notification to the user
- the goal of the quiz is to call this method at the correct times
- start in the sw registeration function and look at the guiding comments in that method
- when code is done, need browser to pick up the changes
- so in browser dev tools, delete the service worker, then refresh the page
- this refreshes and chaces the javascript
- now make a change to the sw; just a comment is sufficient; then refresh the page
- if your code is working, you will see the notification
- head over to the config page to test 

31b) Steps

- to get the project into the sample state use the commands
git reset --hard
git checkout task-update-notify

- once completing the task enter the Test ID update-notify

32b) Solution 

- if you deployed this change you would bump up the version of your cache
- so the old and new cache don't step on each other
- next, we let the user opt into the notification

33) Triggering an Update

- we have notifications appearing
- however our goal is to give users a button they can press to get the latest version
- click this button should tell the waiting service worker take over straightaway
- this bypasses the usual sw life cycle
- then refresh the page so it reloads with the latest assets from the newest cache

33a) Three New Components that Help Us Achieve This

- self.skipWaiting()
- postMessage
- navigator.serviceWorker.addEventListener('controlchange', ...)

33b) self.skipWaiting()

- a sw can call skipWaiting while it's waiting or installing
- this signals that it should not queue behind another service worker; it should take over straightaway
- we want to call this when the user hits the refresh button in our update notification
- how do we send this signal from page to waiting sw?
- ... postMessage

33c) postMessage

// from a page
reg.installing.postMessage({foo: 'bar'});

- your page can send messages to any sw using postMessage

// in the service worker
self.addEventListener('message', function(event) {
  event.data; // {foo: 'bar'}
});

- you can listen for messages in the sw using teh message event

- so, when the user clicks the referesh button, it sends a message to our sw
- the message tells the sw telling it to call skip waiting

33d) navigator.serviceWorker.addEventListener('controlchange', ...)

- we have already seen navigator.serviceworker.controller
- the page gets an event when this value changes
- this means a new service worker has taken over
- use this as a signal to reload the page

34) Quiz: Triggering An Update Quiz

- the branch contains stubbed out methods and comments to guide you

34a) public/js/main/IndexController.js

- _updateReady is called when there is an update to show
- here, tell the new sw to take over the page immediately (i.e. skipWaiting)
- be sure to handle this message in the service worker

- in _registerServiceWorker, there is a todo
- here, listen for the pages controlling service worker changing
- use this as a signal to reload the page

34b) public/js/sw/Index.js

- a todo at the bottom
- here, you listen for the message to take over page control

34c) Steps

- to get the project into the sample state use the commands
git reset --hard
git checkout task-update-reload

- once code is complete need to get it picked up by browser
- again, in dev tools, delete the sw, and refresh page; this will refresh and cache js
- then make a change to sw (i.e. a comment) and refresh page again
- if code is working, you will see notification as before
- pressing refresh will reload the page (i.e. build new cache for new version)

34d) Testing

- make change to sw and refresh page; this will give you an update notification
- on config server, enter the Test ID update-reload and press enter
- then you have 8 secs to hit the refresh button in your notification
- this confirms it's all working