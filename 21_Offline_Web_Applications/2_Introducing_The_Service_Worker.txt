
1) An Overview Of Service Worker

- all it is, is a simple javascript file that sits between you and netwok requests
- it is a type of Web Worker: run separately from your page and can't access the DOM
- but does control pages by intercepting requests as the browser makes them

1a) What Happens After a Request has Been Intercepted

- you can sent the request on to the network as ususal (i.e. through the cache)
- or you can skip the network go to some kind of cache and create a response with information from the cache

2) Register a Service Worker with the Browser

navigator.serviceWorker.register('/sw.js')

- sw.js is your service worker scripts
- this line returns a promise
- so, you get callbacks for success and failure

navigator.serviceWorker.register('/sw.js')
.then(function(reg) {
  console.log('Yay!');
})
.catch(function(err) {
  console.log('Boo!');
});

- if your register a service worker that is already registered, the browser won't register it again
- it will just return the promise associated with the already registered service worker

3) Service Worker Scope

- you can provide a scope to the sevice worker when it is registered
- the service worker will control any page whose url begins with the scope
e.g. /my-app/ | /my-app/hello/world/

- it will ignore those pages that don't begin with the scope
eg.g / | /another-app/ | /my-app (this last one does not have the trailing slash)

navigator.serviceWorker.register('/sw.js', {
  scope: '/my-app/'
});

3a) Multiple Service Workers with Different Scopes

- can have multiple service workers with different scopes
- this is handy say for github pages where multiple projects have same origin
- now you can have a different service worker for each project

https://jakearchibald.github.io/svgomg/
https://jakearchibald.github.io/trained-to-thrill/
https://jakearchibald/github.io/isserviceworkerready/

3b) Default Scope

- determined by the location of the service worker script
- basically the path that the script sits in

SW URL 			Default Scope
/foo/sw.js		/foo/
/foo/bar/sw.js		/foo/bar/
/sw.js			/

- so ususally you don't need to set the scope, you just put the sw in the right place

3c) What is Happening Within the Service Worker

- you listen for specific events
- will introudce these events as course progresses

self.addEventListener('install', function(event) {
  // ...
});

self.addEventListener('activate', function(event) {
  // ...
});

self.addEventListener('fetch', function(event) {
  // ...
});

4) Find Out About Service Worker Support

https://jakearchibald.github.io/isserviceworkerready/

- as of 2015: chrome + opera support it; firefox on its way
- can use it right away though to improve UX
- if browser does not support then users just don't get the good UX

4a) Make Sure to Wrap Code in a Simple Feature Detect

if(navigator.serviceWorker) {
  navigator.serviceWorker.register('/sw.js'); // only runs when browser supports this feature
}

5) wittr/public/js/sw/index.js

- add ServiceWorker to Wittr Project and mess around with requests
- make changes to index.js, bulid system picks it up
- navigate to localhost:8888/sw.js to see changes; extra output in file is from Babel

6) Add Listener for Service Worker "fetch" Event

self.addEventListener('fetch', function() {
  console.log(event.request);
});

- the request for the page's html, in the scope of the sw, 1st goes to the sw
- this triggers a 'fetch' event in the service worker
- there is also a 'fetch' event for every request triggered by the page (css, js, images, etc)
- event if these requests are to another origin
- you can inspect the request in the 'fetch' event listener

7) Registering a Service Worker

- the sw does nothing until you register it with the browser

7a) localhost:8888/sw.js

- see contents of file: babel output + your handler 

7b) wittr/public/js/main/IndexController.js

- this is where you register the sw
- the construction if IndexController sets up the app
- setups up views to get ready for recieving witts
- also, sets up the websocket for the live updates

7c) "Private" Methods in JS begin with Underscore

- js does not have private methods
- but by convention any method that begins with "_" is considered "private"

7d) this._registerServiceWorker

- add registration code here
- the scopte is the entire origin so the default scope is fine

7e) Test on Config Page

Test ID = registered

7f) Solution

- register sw without errors
- avoid errors in older browsers
- log message on success
- log message on failure

IndexController.prototype._registerServiceWorker = function() {
  // avoid errors in older browsers
  if(!navigator.serviceWorker) return;

  navigator.serviceWorker.register('/sw.js')
  .then(function() {
    console.log('Registration worked!');
  })
  .catch(function() {
    console.log('Registration failed');
  });
});

8) SW Event Handler - Limited to HTTPS

- HTTPS: secure form of HTTP
- has access to the request
- can modify the request here (e.g. its headers)

9) HTTP vs HTTPS

- with plain http, any node between the client and server can access and modify the request
- so, without encryption, a client can get content that is very different from what was requested
- malicious scripts can:
-- capture your input data
-- alter databases
-- read cookies
- https encrypts the request

9a) SW

- the sw has a different lifecycle than the pages
- the sw lives longer that pages, so they can be used to persist an attack like this
- BAD!!!
- so, it is not acceptable to allow a malicious middle man to get control of your sw
- so, that is why sw only operates on https requests
- but requests to localhost are exempt; i.e. can be http

10) The Service Worker Lifecycle -  is Complex

- when we create sw, it took 2 refreshes to see the console.log output from the sw event handler
- also, when you edited event handler, takes 2 refreshes again to see new console.log



